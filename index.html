<!DOCTYPE html>
<html>
<head>
  <title>USA Flight Weather Map</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <style>
    html, body, #map {
      height: 100%;
      margin: 0;
    }
  </style>
</head>
<body>
  <div id="map"></div>

  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script>
    const map = L.map('map').setView([39.8283, -98.5795], 4); // Center USA

    // Base map layer
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: 'Map data © <a href="https://openstreetmap.org">OpenStreetMap</a> contributors'
    }).addTo(map);

    function getSeverityColor(severity) {
    if (severity === 0) return "gray";
    if (severity <= 2) return "yellow";
    if (severity <= 4) return "orange";
    if (severity === 5) return "red";
    return "blue"; // fallback
  }

  // Function to create a slightly upward curved line between two points
  function createCurvedLine(startPoint, endPoint) {
    const latlngs = [];
    const points = 20; // Number of points to create a smooth curve
    
    // Calculate control point (for upward curve)
    const midLat = (startPoint[0] + endPoint[0]) / 2;
    const midLon = (startPoint[1] + endPoint[1]) / 2;
    const distance = Math.sqrt(
        Math.pow(endPoint[0] - startPoint[0], 2) + 
        Math.pow(endPoint[1] - startPoint[1], 2)
    );
    
    // Make the curve higher for longer distances
    const curveHeight = distance * 0.15; // Controls how much the curve bends upward
    
    // Create a quadratic Bezier curve
    for (let i = 0; i <= points; i++) {
        const t = i / points;
        
        // Quadratic Bezier curve formula
        const lat = (1-t)*(1-t)*startPoint[0] + 
                   2*(1-t)*t*(midLat + curveHeight) + 
                   t*t*endPoint[0];
                   
        const lon = (1-t)*(1-t)*startPoint[1] + 
                   2*(1-t)*t*midLon + 
                   t*t*endPoint[1];
                   
        latlngs.push([lat, lon]);
    }
    
    return latlngs;
}

    fetch('pirep.json')
    .then(res => res.json())
    .then(data => {
      const pireps = data.pirep;  // ← Fix
      pireps.forEach(p => {
        if (!p.lat || !p.lon) return;
        const info = `FLT LVL: ${p.fltLvl || 'N/A'}<br>Temp: ${p.temp}°C<br>Wind: ${p.wdir}° @ ${p.wspd} kt<br>AC: ${p.acType}`;

        L.circleMarker([p.lat, p.lon], {
          radius: 5,
          fillColor: "blue",
          color: "black",
          weight: 1,
          fillOpacity: 0.8
        }).addTo(map).bindPopup(info);
      });
    });

    fetch('sigmet.json')
    .then(res => res.json())
    .then(data => {
        // Access the correct property - "sigmet" not "sigmets"
        const sigmets = data.sigmet;
        
        console.log("SIGMETs found:", sigmets);
        
        // Check if sigmets exists and is an array
        if (!sigmets || !Array.isArray(sigmets)) return;
        
        sigmets.forEach(p => {
            if (!p.coords || p.coords.length < 3) return; // Need at least 3 points
            
            const info = `Time: ${p.creationTime || 'N/A'}<br>Speed: ${p.movementSpd} kt <br>Direction: ${p.movementDir}°<br>Hazard: ${p.hazard}`;
            
            const latlngs = p.coords.map(c => [c.lat, c.lon]);
            
            // Assuming getSeverityColor is defined elsewhere
            const color = getSeverityColor(p.severity);
            
            L.polygon(latlngs, {
                color: color,
                weight: 2,
                fillOpacity: 0.4
            }).addTo(map).bindPopup(info);
        });
    })
    .catch(error => {
        console.error("Error loading SIGMET data:", error);
    });

    fetch('airports.json')
    .then(res => res.json())
    .then(data => {
        // Filter airports by altitude
        const lowAltitudeAirports = data.waypoints.filter(airport => airport.altitude < 9000);
        const highAltitudeAirports = data.waypoints.filter(airport => airport.altitude >= 9000);
        
        // Add markers for all airports
        lowAltitudeAirports.forEach(airport => {
            L.marker([airport.lat, airport.log], {
                icon: L.divIcon({
                    className: 'airport-marker low-altitude',
                    html: `<div style="width: 10px; height: 10px; background-color: black; transform: rotate(45deg);"></div>`,
                    iconSize: [10, 10]
                })
            }).addTo(map).bindPopup(`${airport.airport_id}<br>Altitude: ${airport.altitude} ft`);
        });
        
        highAltitudeAirports.forEach(airport => {
            L.marker([airport.lat, airport.log], {
                icon: L.divIcon({
                    className: 'airport-marker high-altitude',
                    html: `<div style="background-color: red; width: 10px; height: 10px; border-radius: 50%;"></div>`,
                    iconSize: [10, 10]
                })
            }).addTo(map).bindPopup(`${airport.airport_id}<br>Altitude: ${airport.altitude} ft`);
        });
        
        // Draw curved lines between low altitude airports if there are at least 2
        if (lowAltitudeAirports.length >= 2) {
            // Sort airports west to east for connection
            lowAltitudeAirports.sort((a, b) => a.log - b.log);
            
            // Connect the airports with curved lines
            for (let i = 0; i < lowAltitudeAirports.length - 1; i++) {
                const start = [lowAltitudeAirports[i].lat, lowAltitudeAirports[i].log];
                const end = [lowAltitudeAirports[i+1].lat, lowAltitudeAirports[i+1].log];
                
                // Create a curved line
                const latlngs = createCurvedLine(start, end);
                
                L.polyline(latlngs, {
                    color: 'black',
                    weight: 3,
                    opacity: 0.7,
                    curvature: 0.3
                }).addTo(map);
            }
        }
    })
    .catch(error => {
        console.error("Error loading airport data:", error);
    });


    // 2. List of airport files to load
    // const airportFiles = ['output_KPHX.json'];

    // airportFiles.forEach(file => {
    //   fetch(file)
    //     .then(res => res.json())
    //     .then(data => {
    //       const isTerminal = data.altitude < 8000;
    //       const markerColor = isTerminal ? "green" : "purple";
    //       const popup = `
    //         <b>${data.airport_id}</b><br>
    //         Altitude: ${data.altitude} ft<br>
    //         <b>METAR:</b> ${data.metar[0]?.rawText || 'N/A'}<br>
    //         <b>TAF:</b> ${data.taf[0]?.rawText || 'N/A'}
    //       `;

    //       L.circleMarker([data.lat, data.lon], {
    //         radius: 7,
    //         fillColor: markerColor,
    //         color: "black",
    //         weight: 1,
    //         fillOpacity: 0.9
    //       }).addTo(map).bindPopup(popup);
    //       sigmetArray=output_KPHX.json
    //       // renderSIGMETs(sigmetArray, map)
    //     });
    // });
  </script>
</body>
</html>
